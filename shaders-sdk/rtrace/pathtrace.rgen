#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive  : require
#extension GL_EXT_scalar_block_layout   : require
#extension GL_EXT_shader_realtime_clock : require

#extension GL_EXT_shader_explicit_arithmetic_types         : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : require
#extension GL_EXT_shader_subgroup_extended_types_int8      : require
#extension GL_EXT_shader_subgroup_extended_types_int16     : require
#extension GL_EXT_shader_subgroup_extended_types_int64     : require
#extension GL_EXT_shader_subgroup_extended_types_float16   : require
#extension GL_EXT_shader_16bit_storage                     : require
#extension GL_EXT_shader_8bit_storage                      : require

precision highp float;
precision highp int;
#include "./index.glsl"


layout (binding = 2, set = 3) uniform accelerationStructureNV Scene;

RayPayloadData PrimaryRay;

void main() { // Hi-DPI adaptation
    const vec2 curPixel = vec2(gl_LaunchIDNV.xy) + 0.5f;
    const vec2 sizPixel = vec2(gl_LaunchSizeNV.xy);

    // 
    vec4 origss = vec4(divW(vec4((curPixel/sizPixel)*2.f-1.f,0.001f,1.f)*projectionInv),1.f);
    vec4 targss = vec4(divW(vec4((curPixel/sizPixel)*2.f-1.f,0.999f,1.f)*projectionInv),1.f);

    // 
    vec3 origin = origss*modelviewInv;
    vec3 target = targss*modelviewInv;
    vec3 raydir = normalize(target - origin);

    // 
    vec3 signal = vec3(0.f,0.f,0.f);
    vec3 energy = vec3(1.f,1.f,1.f);
    bool emission = false;

    // 
    uint i = 0u; signal = raydir.xyz*0.5f+0.5f;
    for (i = 0u;i<4u;i++) {
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
            0, 1, 0,
            origin.xyz, 0.0001f,
            raydir.xyz, 10000.f,
            0);

        // 
        float depth = PrimaryRay.fdata.z;
        if (depth >= 10000.f) { // 
            energy *= vec3(0.9f,0.98,0.999f);
        } else {
            energy *= vec3(0.5f,0.5f,1.f);
        };

        // 
        if (i == 0u) { origin.xyz += raydir.xyz * depth; };
    };

    const vec4 directSample = imageLoad(writeImages[DIFFUSED_FLIP0],ivec2(gl_LaunchIDNV.xy));
    const vec4 locateSample = vec4(origin.xyz,1.f);//imageLoad(writeImages[SAMPLING_FLIP0],ivec2(gl_LaunchIDNV.xy));
    imageStore(writeImages[DIFFUSED_FLIP1], ivec2(gl_LaunchIDNV.xy), vec4(directSample.xyz + energy, directSample.w + 1.f));
    imageStore(writeImages[SAMPLING_FLIP1], ivec2(gl_LaunchIDNV.xy), vec4(locateSample));
};
