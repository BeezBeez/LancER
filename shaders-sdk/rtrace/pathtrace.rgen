#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive  : require
#extension GL_EXT_scalar_block_layout   : require
#extension GL_EXT_shader_realtime_clock : require
#extension GL_EXT_samplerless_texture_functions : require

#extension GL_EXT_shader_explicit_arithmetic_types         : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : require
#extension GL_EXT_shader_subgroup_extended_types_int8      : require
#extension GL_EXT_shader_subgroup_extended_types_int16     : require
#extension GL_EXT_shader_subgroup_extended_types_int64     : require
#extension GL_EXT_shader_subgroup_extended_types_float16   : require
#extension GL_EXT_shader_16bit_storage                     : require
#extension GL_EXT_shader_8bit_storage                      : require

precision highp float;
precision highp int;
#include "./index.glsl"


layout ( binding = 2, set = 1 ) uniform accelerationStructureNV Scene;
layout ( location = 0 ) rayPayloadNV RayPayloadData PrimaryRay;

// TODO: Hybrid Path Tracing
void main() { // Hi-DPI adaptation
    ivec2 curPixel = ivec2(gl_LaunchIDNV.xy), invPixel = ivec2(gl_LaunchIDNV.x,gl_LaunchSizeNV.y-gl_LaunchIDNV.y-1u);
    ivec2 sizPixel = ivec2(gl_LaunchSizeNV.xy);

    // 
    const vec4 worldsSample = texelFetch(frameBuffers[SAMPLING], ivec2(invPixel.xy),0);
    const vec3 cameraSample = worldsSample*modelview;

    // 
    vec3 raydir = (modelviewInv * normalize(cameraSample.xyz)).xyz;
    vec3 origin = worldsSample.xyz;

    // DEBUG
    origin.xyz -= raydir.xyz;

    // 
    vec3 signal = vec3(0.f,0.f,0.f);
    vec3 energy = vec3(1.f,1.f,1.f);
    bool emission = false;

    // 
    uint i = 0u; signal = raydir.xyz*0.5f+0.5f;
    for (i = 0u; i < 1u; i++) {
        //PrimaryRay.fdata.xyz = vec3(0.f,0.f,10000.f);
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
            0, 1, 0,
            origin.xyz, 0.0001f,
            raydir.xyz, 10000.f,
            0);

        // 
        float depth = PrimaryRay.fdata.z;
        if (depth >= 9999.f) { // 
            energy *= vec3(0.9f,0.98,0.999f); emission = true;
        } else {
            energy *= vec3(0.5f,0.75f,1.f);
        };

        // 
        if (i == 0u) { origin.xyz += raydir.xyz * depth; };

        // 
        //energy *= vec3(depth,depth,depth)*0.5f;
    };

    // 
    const vec4 directSample =  imageLoad(writeImages[DIFFUSED_FLIP0], ivec2(gl_LaunchIDNV.xy));
    //const vec4 locateSample = imageLoad(writeImages[SAMPLING_FLIP0],ivec2(gl_LaunchIDNV.xy));
    imageStore(writeImages[DIFFUSED_FLIP1], ivec2(gl_LaunchIDNV.xy), vec4(directSample.xyz + energy, directSample.w + 1.f));
    imageStore(writeImages[SAMPLING_FLIP1], ivec2(gl_LaunchIDNV.xy), vec4(worldsSample.xyz,1.f));
    imageStore(writeImages[DIFFUSED_FLIP0], ivec2(gl_LaunchIDNV.xy), vec4(0.f,0.f,0.f,0.f)); // Access And Clear Manually
};
