#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive  : require
#extension GL_EXT_scalar_block_layout   : require
#extension GL_EXT_shader_realtime_clock : require

#extension GL_EXT_shader_explicit_arithmetic_types         : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : require
#extension GL_EXT_shader_subgroup_extended_types_int8      : require
#extension GL_EXT_shader_subgroup_extended_types_int16     : require
#extension GL_EXT_shader_subgroup_extended_types_int64     : require
#extension GL_EXT_shader_subgroup_extended_types_float16   : require
#extension GL_EXT_shader_16bit_storage                     : require
#extension GL_EXT_shader_8bit_storage                      : require

precision highp float;
precision highp int;
#include "./index.glsl"


layout (binding = 2, set = 3) uniform accelerationStructureNV Scene;

RayPayloadData PrimaryRay;

void main() { // Hi-DPI adaptation
    const vec2 curPixel = vec2(gl_LaunchIDNV.xy) + 0.5f;
    const vec2 sizPixel = vec2(gl_LaunchSizeNV.xy);

    vec4 origss = vec4(divW(vec4((curPixel/sizPixel)*2.f-1.f,0.001f,1.f)*projectionInv),1.f);
    vec4 targss = vec4(divW(vec4((curPixel/sizPixel)*2.f-1.f,0.999f,1.f)*projectionInv),1.f);

    vec3 origin = origss*modelviewInv;
    vec3 target = targss*modelviewInv;
    vec3 raydir = normalize(target - origin);

    vec3 signal = vec3(0.f,0.f,0.f);
    vec3 energy = vec3(1.f,1.f,1.f);
    bool emission = false;

    signal = raydir.xyz*0.5f+0.5f;

    uint i = 0u;
    for (i = 0u;i<4u;i++) {
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
            0,
            1,
            0,
            origin.xyz,
            0.001f,
            raydir.xyz,
            100.f,
            0);

        // 
        float depth = PrimaryRay.fdata.z;
        if (depth >= 10000.f) { // 
            energy *= vec3(0.9f,0.98,0.999f);
        } else {
            energy *= vec3(0.5f,0.5f,1.f);
        };
    };

/*
    for (i = 0u;i<4u;i++) {
        Box box = { -1.f.xxx, 1.f.xxx };
        vec4 sphere = vec4(vec3(0.f,12.f,12.f), 1.f);
        vec2 boxdepth = boxIntersect(origin.xyz, raydir.xyz, box.min, box.max); 
        float bdepth = (boxdepth.x <= boxdepth.y && boxdepth.y >= 0.f) ? (boxdepth.x >= 0.f ? min(boxdepth.x, boxdepth.y) : max(boxdepth.x, boxdepth.y)) : 10000.f;
        float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : 0.f;
        float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
        float depth = min(min(sdepth, bdepth), pdepth);
        vec3 lastps = origin.xyz + raydir.xyz*depth;



        if (depth >= 10000.f) { // Midnight Skylight Depth
            PrimaryRay.udata.x = 1u;
            PrimaryRay.fdata.xyz = 0.f.xxx;//vec3(0.9f, 0.96f, 0.99f) * 0.5f;
            PrimaryRay.normal.xyz = raydir.xyz;
        } else 

        if (fequal(depth, sdepth)) { // Sphere Light Depth
            PrimaryRay.udata.x = 1u;
            PrimaryRay.fdata.xyz = vec3(2.f, 2.f, 2.f);
            PrimaryRay.normal.xyz = normalize(lastps.xyz - sphere.xyz);
        } else 

        if (fequal(depth, bdepth)) { // Box Depth
            PrimaryRay.udata.x = 0u;
            PrimaryRay.fdata.xyz = vec3(0.9f, 0.6f, 0.6f);
            PrimaryRay.normal.xyz = normalize(boxNormal(lastps.xyz,box.min,box.max));
        } else 

        if (fequal(depth, pdepth)) { // Plane Depth
            PrimaryRay.udata.x = 0u;
            PrimaryRay.fdata.xyz = vec3(0.9f, 0.9f, 0.9f);
            PrimaryRay.normal.xyz = vec3(0.f,1.f,0.f);
        } else 
        
        {
            PrimaryRay.udata.x = 0u;
            PrimaryRay.fdata.xyz = vec3(0.f);
            PrimaryRay.normal.xyz = vec3(0.f,0.f,0.f);
        }

        // 
        origin.xyz = lastps.xyz + faceforward(PrimaryRay.normal.xyz,raydir.xyz,PrimaryRay.normal.xyz) * 0.0001f;
        raydir.xyz = randomHemisphereCosine(PrimaryRay.normal.xyz,uvec2(gl_LaunchIDNV.xy));
        energy.xyz *= PrimaryRay.fdata.xyz;

        // 
        if ( i == 0 ) { // Like In Rasterization
            //signal = PrimaryRay.normal.xyz*0.5f+0.5f;
            imageStore(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy), vec4(lastps,1.f));
            imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), vec4(exchange(energy.xyz,1.f.xxx),1.f));
        };

        // Finalize 
        if (dot(energy.xyz,1.f.xxx) < 0.001f) { emission = false; break; };
        if (PrimaryRay.udata.x == 1u) { emission = true; break; };
    };
*/

    // 
    //if (!emission) { energy *= 0.f; };

    // Diffuse Samples Overall
    //if ( i > 0 ) {
        const vec4 originSample = texelFetch(frameBuffers[DIFFUSED_FLIP0],ivec2(gl_LaunchIDNV.xy),0);
        const vec4 locateSample = texelFetch(frameBuffers[SAMPLING_FLIP0],ivec2(gl_LaunchIDNV.xy),0);
        imageStore(writeImages[DIFFUSED_FLIP1], ivec2(gl_LaunchIDNV.xy), vec4(originSample.xyz + energy, originSample.w + 1.f));
        imageStore(writeImages[SAMPLING_FLIP1], ivec2(gl_LaunchIDNV.xy), vec4(locateSample));
    //};

    
};
