#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive          : require
#extension GL_EXT_scalar_block_layout           : require
#extension GL_EXT_shader_realtime_clock         : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_EXT_nonuniform_qualifier          : require

#extension GL_EXT_shader_explicit_arithmetic_types         : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : require
#extension GL_EXT_shader_subgroup_extended_types_int8      : require
#extension GL_EXT_shader_subgroup_extended_types_int16     : require
#extension GL_EXT_shader_subgroup_extended_types_int64     : require
#extension GL_EXT_shader_subgroup_extended_types_float16   : require
#extension GL_EXT_shader_16bit_storage                     : require
#extension GL_EXT_shader_8bit_storage                      : require

precision highp float;
precision highp int;
#include "./index.glsl"


layout ( binding = 2, set = 1 ) uniform accelerationStructureNV Scene;
layout ( location = 0 ) rayPayloadNV RayPayloadData PrimaryRay;

// TODO: Hybrid Path Tracing
void main() { // Hi-DPI adaptation
    PrimaryRay.position  = vec4(0.f);
    PrimaryRay.texcoords = vec4(0.f);
    PrimaryRay.normals   = vec4(0.f);
    PrimaryRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
    PrimaryRay.udata.xyz = uvec3(0u);

    // 
    ivec2 curPixel = ivec2(gl_LaunchIDNV.xy), invPixel = ivec2(gl_LaunchIDNV.x,gl_LaunchSizeNV.y-gl_LaunchIDNV.y-1u);
    ivec2 sizPixel = ivec2(gl_LaunchSizeNV.xy);
    uint packed = pack32(u16vec2(curPixel));

    // 
    //const vec4 colourSample = texelFetch(frameBuffers[COLORING], ivec2(invPixel.xy),0);
    //const vec4 normalSample = texelFetch(frameBuffers[NORMALED], ivec2(invPixel.xy),0);
    //const vec4 worldsSample = texelFetch(frameBuffers[POSITION], ivec2(invPixel.xy),0);
    //const vec3 cameraSample = vec4(worldsSample.xyz,1.f)*modelview;

    // 
    //vec3 raydir = (modelview * normalize(cameraSample.xyz)).xyz;
    //vec3 origin = worldsSample.xyz;

    vec2 shift = random2(uvec2(rdata[0],packed)), pixel = vec2(invPixel)+shift;
    vec4 origss = vec4(divW(vec4((pixel/sizPixel)*2.f-1.f,0.001f,1.f)*projectionInv),1.f);
    vec4 targss = vec4(divW(vec4((pixel/sizPixel)*2.f-1.f,0.999f,1.f)*projectionInv),1.f);

    vec3 origin = origss*modelviewInv;
    vec3 target = targss*modelviewInv;
    vec3 raydir = normalize(target - origin);
    vec3 smorig = origin;

    // DEBUG
    //origin.xyz -= raydir.xyz * 0.1f;

    // 
    vec3 signal = vec3(0.f,0.f,0.f);
    vec3 energy = vec3(1.f,1.f,1.f);
    bool emission = false;

//random2(uvec2(rdata[0],packed))

    // 
    Box box = { -1.f.xxx, 1.f.xxx }; // TODO: Change Coordinate
    vec4 sphere = vec4(vec3(8.f,8.f,8.f), 4.f);

    uint i = 0u; signal = raydir.xyz*0.5f+0.5f;
    for (i = 0u; i < 4u; i++) {
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
            0, 1, 0,
            origin.xyz, 0.0001f,
            raydir.xyz, 10000.f,
            0);

        // 
        float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
        float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
        float depth = min(min(PrimaryRay.fdata.z,sdepth),pdepth);
        //float depth = min(PrimaryRay.fdata.z,sdepth);
        
        // TODO: better depth system
        if (depth >= 9999.f) { // Skybox
            energy *= vec3(0.9f,0.98,0.999f); emission = true;
            //energy *= vec3(0.f); emission = true;
        } else 
        if (depth == PrimaryRay.fdata.z) { // Primitive
            energy *= PrimaryRay.normals.xyz * 0.5f + 0.5f;
        } else 
        if (depth == sdepth) { // Light Sphere
            energy *= 10.f.xxx; emission = true;
            PrimaryRay.normals.xyz = normalize((origin.xyz + raydir.xyz * sdepth) - sphere.xyz);
        } else 
        if (depth == pdepth) { // Plane
            energy *= vec3(0.8f);
            PrimaryRay.normals.xyz = vec3(0.f,1.f,0.f);
        } else { // Error as Skybox
            energy *= vec3(0.9f,0.98,0.999f); emission = true;
            //energy *= vec3(0.f); emission = true;
        };

        // 
        origin.xyz += raydir.xyz * depth;
        if (i == 0u) { smorig.xyz = origin.xyz; };

        // 
        raydir.xyz = randomHemisphereCosine(PrimaryRay.normals.xyz,uvec2(gl_LaunchIDNV.xy));
        origin.xyz += faceforward(PrimaryRay.normals.xyz,raydir.xyz,-PrimaryRay.normals.xyz) * 0.0001f;
        

        if (emission) break; // if found emission, break
    };

    if (!emission) { energy *= 0.f; };

    // 
    const vec4 directSample = imageLoad(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy));
    const vec4 locateSample = imageLoad(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy));
    imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), vec4(energy.xyz + directSample.xyz, directSample.w + 1.f));
    imageStore(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy), vec4(smorig.xyz,1.f));
};
