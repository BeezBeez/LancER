#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_realtime_clock : require
#include "./index.glsl"


layout (binding = 1, set = 0) uniform accelerationStructureNV Scene;

//layout ( location = 0 ) rayPayloadNV RayPayload PrimaryRay;

RayPayloadData PrimaryRay;

//const float PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   
//const float PI  = 3.14159265358979323846264 * 00000.1; // PI
//const float SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two

//float gold_noise(in vec2 coordinate, in float seed){
//    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);
//}

//const float PIh = 3.14159265358979323846264*2.0;
//const float BLUR_RADIUS = 20.f;

//const vec4 shapeColors[2] = {vec4(0.1f,0.6f,0.1f,0.6f), vec4(0.6f,0.1f,0.1f,0.6f)};


vec3 exchange(inout vec3 orig, in vec3 data) {
    vec3 old = orig; orig = data; return old;
};

void main() {
    // Hi-DPI adaptation
    const vec2 curPixel = vec2(gl_LaunchIDNV.xy) + 0.5f;
    const vec2 sizPixel = vec2(gl_LaunchSizeNV.xy);

    vec4 origin = divW(vec4((curPixel/sizPixel)*2.f-1.f,0.001f,1.f)*projectionInv)*modelviewInv;
    vec4 target = divW(vec4((curPixel/sizPixel)*2.f-1.f,0.999f,1.f)*projectionInv)*modelviewInv;
    vec4 raydir = normalize(target - origin);

    vec3 energy = vec3(1.f,1.f,1.f);
    bool emission = false;

    vec3 lastps = origin.xyz;

    uint i = 0u;
    for (i;i<4u;i++) {
        /* TODO: Add Triangle Tracing
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                 0,
                 1,
                 0,
                 origin.xyz,
                 0.001f,
                 raydir.xyz,
                 100.f,
                 0);
        */ 

        Box box = { -1.f.xxx, 1.f.xxx };
        vec4 sphere = vec4(vec3(10.f,10.f,10.f), 2.f);
        vec2 boxdepth = boxIntersect(origin.xyz, raydir.xyz, box.min, box.max); 
        float bdepth = (boxdepth.x <= boxdepth.y && boxdepth.y >= 0.f) ? (boxdepth.x >= 0.f ? min(boxdepth.x, boxdepth.y) : max(boxdepth.x, boxdepth.y)) : 10000.f;
        float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth >= 0.f ? 10000.f : 0.f;
        float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f));
        float depth = min(min(min(10000.f, sdepth), bdepth), pdepth <= 0.f ? 10000.f : pdepth );
        vec3 normal = vec3(0.f), lastps = origin.xyz + raydir.xyz*depth;



        if (depth >= 10000.f) { // Midnight Skylight Depth
            PrimaryRay.udata.x = 1u;
            PrimaryRay.fdata.xyz = vec3(0.9f, 0.96f, 0.99f) * 0.5f;
            PrimaryRay.normal.xyz = raydir.xyz;
        } else 

        if (depth == sdepth) { // Sphere Light Depth
            PrimaryRay.udata.x = 1u;
            PrimaryRay.fdata.xyz = vec3(10.f, 10.f, 10.f);
            PrimaryRay.normal.xyz = normalize(lastps.xyz - sphere.xyz);
        } else 

        if (depth == bdepth) { // Box Depth
            PrimaryRay.udata.x = 0u;
            PrimaryRay.fdata.xyz = vec3(0.9f, 0.6f, 0.6f);
            PrimaryRay.normal.xyz = boxNormal(lastps.xyz,box.min,box.max);
        } else 

        if (depth == pdepth) { // Plane Depth
            PrimaryRay.udata.x = 0u;
            PrimaryRay.fdata.xyz = vec3(0.9f, 0.9f, 0.9f);
            PrimaryRay.normal.xyz = vec3(0.f,1.f,0.f);
        };

        // 
        origin.xyz = lastps.xyz + faceforward(PrimaryRay.normal.xyz,raydir.xyz,PrimaryRay.normal.xyz) * 0.0001f;
        raydir.xyz = randomHemisphereCosine(PrimaryRay.normal.xyz);
        energy.xyz *= PrimaryRay.fdata.xyz;

        // 
        if ( i == 0 ) { // Like In Rasterization
            imageStore(writeImages[SAMPLES], ivec2(gl_LaunchIDNV.xy), vec4(lastps.xyz,1.f));
            imageStore(writeImages[COLORED], ivec2(gl_LaunchIDNV.xy), vec4(exchange(energy.xyz,1.f.xxx),1.f));
        };

        // Finalize 
        if (dot(energy.xyz,1.f.xxx) < 0.001f) { emission = false; break; };
        if (PrimaryRay.udata.x == 1u) { emission = true; break; };
    };

    // 
    if (!emission) { energy *= 0.f; };

    // Diffuse Samples Overall
    if ( i > 0 ) {
        const vec4 originSample = texelFetch(frameBuffers[DIFFUSE],ivec2(gl_LaunchIDNV.xy),0);
        imageStore(writeImages[DIFFUSE], ivec2(gl_LaunchIDNV.xy), vec4(originSample.xyz + energy, originSample.w + (emission?1.f:0.f)));
    } else {
        imageStore(writeImages[COLORED], ivec2(gl_LaunchIDNV.xy), vec4(exchange(energy.xyz,1.f.xxx),1.f));
    };

};
