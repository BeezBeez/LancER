#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive          : require
#include "./driver.glsl"


layout ( binding = 2, set = 1 ) uniform accelerationStructureNV Scene;
layout ( location = 0 ) rayPayloadNV RayPayloadData PrimaryRay;
layout ( location = 1 ) rayPayloadNV RayPayloadData ShadowsRay;


vec4 shiftByPixel(in vec4 wpos, in uint packed){
    vec2 sizpx = vec2(gl_LaunchSizeNV.xy);
    vec2 shift = random2(uvec2(rdata[0],packed));
    vec4 sspos = vec4(vec4(divW(wpos * projectionInv),1.f) * modelviewInv, 1.f);
    sspos.xy += shift/sizpx;
    return vec4(divW(vec4(sspos * modelview, 1.f) * projection), 1.f);
};


// TODO: Hybrid Path Tracing
void main() { // Hi-DPI adaptation
    PrimaryRay.position  = vec4(0.f);
    PrimaryRay.texcoords = vec4(0.f);
    PrimaryRay.normals   = vec4(0.f);
    PrimaryRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
    PrimaryRay.udata.xyz = uvec3(0u);

    // 
    ivec2 curPixel = ivec2(gl_LaunchIDNV.xy), invPixel = ivec2(gl_LaunchIDNV.x,gl_LaunchSizeNV.y-gl_LaunchIDNV.y-1u);
    ivec2 sizPixel = ivec2(gl_LaunchSizeNV.xy);
    uint packed = pack32(u16vec2(curPixel));

    // TODO: transform normals (include in ray tracers)
    const vec4 colourSample = texelFetch(frameBuffers[COLORING], ivec2(invPixel.xy),0);
    const vec4 normalSample = texelFetch(frameBuffers[NORMALED], ivec2(invPixel.xy),0);
    const vec4 worldsSample = texelFetch(frameBuffers[POSITION], ivec2(invPixel.xy),0);
    const vec3 cameraSample = vec4(worldsSample.xyz,1.f)*modelview;
    const bool isBackground = all(equal(worldsSample.xyz,0.f.xxx));

    // 
    vec3 lnormal = normalSample.xyz;
    vec3 raydir = (modelview * normalize(cameraSample.xyz)).xyz;
    vec3 origin = worldsSample.xyz;
    vec3 smorig = origin;
    raydir.xyz = randomHemisphereCosine(PrimaryRay.normals.xyz,uvec2(gl_LaunchIDNV.xy));
    origin.xyz += faceforward(PrimaryRay.normals.xyz,-raydir.xyz,PrimaryRay.normals.xyz) * 0.0001f;

    //vec2 shift = random2(uvec2(rdata[0],packed)), pixel = vec2(invPixel);//+shift;
    //vec4 origss = vec4(divW(vec4((pixel/sizPixel)*2.f-1.f,0.001f,1.f)*projectionInv),1.f);
    //vec4 targss = vec4(divW(vec4((pixel/sizPixel)*2.f-1.f,0.999f,1.f)*projectionInv),1.f);

    //vec3 origin = origss*modelviewInv;
    //vec3 target = targss*modelviewInv;
    //vec3 raydir = normalize(target - origin);

    // DEBUG
    //origin.xyz -= raydir.xyz * 0.1f;

    // 
    //vec4 signal = vec4(0.f,0.f,0.f,1.f);
    vec4 signal = vec4(0.f,0.f,0.f,1.f);
    vec3 energy = vec3(1.f,1.f,1.f);

    bool emission = false;

//random2(uvec2(rdata[0],packed))

    // 
    Box box = { -1.f.xxx, 1.f.xxx }; // TODO: Change Coordinate
    vec4 sphere = vec4(vec3(8.f,8.f,4.f), 4.f); vec3 lightc = 5.f.xxx;
    const vec3 skyColor = vec3(0.9f,0.98,0.999f); // TODO: Use 1.f and texture shading (include from rasterization)
    //const vec3 skyColor = 0.f.xxx;

    // 
    const uint ITERATION_COUNT = 3u;
    uint i = 0u; if (!isBackground) 
    for (i = 0u; i < ITERATION_COUNT; i++) { //
        ShadowsRay.position  = vec4(0.f);
        ShadowsRay.texcoords = vec4(0.f);
        ShadowsRay.normals   = vec4(0.f);
        ShadowsRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
        ShadowsRay.udata.xyz = uvec3(0u);

        // Shadows Rays
        if (i >= 0u) {
            vec3 lightp = sphere.xyz + randomSphere(uvec2(gl_LaunchIDNV.xy)) * sphere.w; float shdist = distance(lightp.xyz,origin.xyz);
            vec3 lightd = normalize(lightp.xyz - origin.xyz);

            traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                1, 1, 1,
                origin.xyz, 0.0001f,
                lightd.xyz, 10000.f,
                1);

            float sdepth = raySphereIntersect(origin.xyz,lightd,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
            float depth = min(sdepth,ShadowsRay.fdata.z)+sphere.w;
            //float depth = ShadowsRay.fdata.z;

            float cos_a_max = sqrt(1.f - clamp(sphere.w * sphere.w / dot(sphere.xyz-origin.xyz, sphere.xyz-origin.xyz), 0.f, 1.f));
            if (depth >= (shdist-0.001f)) { signal += vec4(energy * (2.f * (1.f - cos_a_max)) * clamp(dot( lightd, lnormal ), 0.f, 1.f) * lightc * 2.f, 0.f); };
        };

        // Primary Rays
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
            0, 1, 0,
            origin.xyz, 0.0001f,
            raydir.xyz, 10000.f,
            0);

        // 
        float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
        float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
        //float depth = min(min(PrimaryRay.fdata.z,sdepth),pdepth);
        float depth = min(PrimaryRay.fdata.z,sdepth);
        
        //const vec3 skyColor = 0.f.xxx;

        // TODO: better depth system
        bool couldReflection = false;
        if (depth >= 9999.f) { // Skybox
            signal.xyz += energy * skyColor; emission = true;
        } else 
        if (depth == PrimaryRay.fdata.z) { // Primitive
            //energy *= PrimaryRay.normals.xyz * 0.5f + 0.5f;
            energy *= vec3(0.9f,0.8f,0.8f)*0.75f;
        } else 
        if (depth == sdepth) { // Light Sphere
            //signal.xyz += energy * lightc; emission = true;
            signal.xyz += energy * 0.f; emission = true; // confirm diffuse lightning
            PrimaryRay.normals.xyz = normalize((origin.xyz + raydir.xyz * sdepth) - sphere.xyz);
        } else 
        if (depth == pdepth) { // Plane
            energy *= vec3(0.8f);
            PrimaryRay.normals.xyz = vec3(0.f,1.f,0.f);
            couldReflection = true;
        } else { // Error as Skybox
            signal.xyz += energy * skyColor; emission = true;
        };
        origin.xyz += raydir.xyz * depth;
        //if (i == 0u) { smorig.xyz = origin.xyz; };

        // 
        PrimaryRay.normals.xyz = faceforward(PrimaryRay.normals.xyz,raydir.xyz,PrimaryRay.normals.xyz); // interverse into incoming ray
        if (couldReflection) {
            raydir.xyz = reflect(raydir.xyz,PrimaryRay.normals.xyz);
        } else {
            raydir.xyz = randomHemisphereCosine(PrimaryRay.normals.xyz,uvec2(gl_LaunchIDNV.xy));
        };
        origin.xyz += faceforward(PrimaryRay.normals.xyz,-raydir.xyz,PrimaryRay.normals.xyz) * 0.0001f;
        lnormal.xyz = PrimaryRay.normals.xyz;

        // 
        if (emission) { break; }; // if found emission, break
    } else {
        signal.xyz += energy * skyColor; emission = true;
    };

    

    //if (emission) { signal += vec4(energy, 1.f); } else { signal.w = 1.f; };

    // 
    const vec4 directSample = imageLoad(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy));
    const vec4 locateSample = imageLoad(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy));
    imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), signal + directSample);
    //imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), signal);
    imageStore(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy), worldsSample);
};
