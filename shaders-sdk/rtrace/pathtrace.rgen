#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive          : require
#extension GL_EXT_scalar_block_layout           : require
#extension GL_EXT_shader_realtime_clock         : require
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_EXT_nonuniform_qualifier          : require

#extension GL_EXT_shader_explicit_arithmetic_types         : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : require
#extension GL_EXT_shader_subgroup_extended_types_int8      : require
#extension GL_EXT_shader_subgroup_extended_types_int16     : require
#extension GL_EXT_shader_subgroup_extended_types_int64     : require
#extension GL_EXT_shader_subgroup_extended_types_float16   : require
#extension GL_EXT_shader_16bit_storage                     : require
#extension GL_EXT_shader_8bit_storage                      : require

precision highp float;
precision highp int;
#include "./index.glsl"


layout ( binding = 2, set = 1 ) uniform accelerationStructureNV Scene;
layout ( location = 0 ) rayPayloadNV RayPayloadData PrimaryRay;
layout ( location = 1 ) rayPayloadNV RayPayloadData ShadowsRay;

// TODO: Hybrid Path Tracing
void main() { // Hi-DPI adaptation
    PrimaryRay.position  = vec4(0.f);
    PrimaryRay.texcoords = vec4(0.f);
    PrimaryRay.normals   = vec4(0.f);
    PrimaryRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
    PrimaryRay.udata.xyz = uvec3(0u);

    // 
    ivec2 curPixel = ivec2(gl_LaunchIDNV.xy), invPixel = ivec2(gl_LaunchIDNV.x,gl_LaunchSizeNV.y-gl_LaunchIDNV.y-1u);
    ivec2 sizPixel = ivec2(gl_LaunchSizeNV.xy);
    uint packed = pack32(u16vec2(curPixel));

    // 
    //const vec4 colourSample = texelFetch(frameBuffers[COLORING], ivec2(invPixel.xy),0);
    //const vec4 normalSample = texelFetch(frameBuffers[NORMALED], ivec2(invPixel.xy),0);
    //const vec4 worldsSample = texelFetch(frameBuffers[POSITION], ivec2(invPixel.xy),0);
    //const vec3 cameraSample = vec4(worldsSample.xyz,1.f)*modelview;

    // 
    //vec3 raydir = (modelview * normalize(cameraSample.xyz)).xyz;
    //vec3 origin = worldsSample.xyz;

    vec2 shift = random2(uvec2(rdata[0],packed)), pixel = vec2(invPixel)+shift;
    vec4 origss = vec4(divW(vec4((pixel/sizPixel)*2.f-1.f,0.001f,1.f)*projectionInv),1.f);
    vec4 targss = vec4(divW(vec4((pixel/sizPixel)*2.f-1.f,0.999f,1.f)*projectionInv),1.f);

    vec3 origin = origss*modelviewInv;
    vec3 target = targss*modelviewInv;
    vec3 raydir = normalize(target - origin);
    vec3 smorig = origin;

    // DEBUG
    //origin.xyz -= raydir.xyz * 0.1f;

    // 
    vec4 signal = vec4(0.f,0.f,0.f,1.f);
    vec3 energy = vec3(1.f,1.f,1.f);

    bool emission = false;

//random2(uvec2(rdata[0],packed))

    // 
    Box box = { -1.f.xxx, 1.f.xxx }; // TODO: Change Coordinate
    vec4 sphere = vec4(vec3(8.f,8.f,8.f), 4.f);

    // 
    uint i = 0u; vec3 lnormal = vec3(0.f);
    for (i = 0u; i < 4u; i++) {
        //
        ShadowsRay.position  = vec4(0.f);
        ShadowsRay.texcoords = vec4(0.f);
        ShadowsRay.normals   = vec4(0.f);
        ShadowsRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
        ShadowsRay.udata.xyz = uvec3(0u);

        // Shadows Rays
        if (i >= 1u) {
            vec3 lightp = sphere.xyz + randomSphere(uvec2(gl_LaunchIDNV.xy)) * sphere.w; float shdist = distance(lightp.xyz,origin.xyz);
            vec3 lightd = normalize(lightp.xyz - origin.xyz);

            traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                1, 1, 1,
                origin.xyz, 0.0001f,
                lightd.xyz, 10000.f,
                1);

            float sdepth = raySphereIntersect(origin.xyz,lightd,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
            float depth = min(sdepth,PrimaryRay.fdata.z);

            float cos_a_max = sqrt(1.f - clamp(sphere.w * sphere.w / dot(sphere.xyz-origin.xyz, sphere.xyz-origin.xyz), 0.f, 1.f));
            if (depth >= shdist-0.001f) { signal += vec4(energy * (2.f * (1.f - cos_a_max)) * clamp(dot( lightd, lnormal ), 0.f, 1.f) * 10.f.xxx, 1.f); };
        };

        // Primary Rays
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
            0, 1, 0,
            origin.xyz, 0.0001f,
            raydir.xyz, 10000.f,
            0);

        // 
        float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
        float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
        float depth = min(min(PrimaryRay.fdata.z,sdepth),pdepth);
        //float depth = min(PrimaryRay.fdata.z,sdepth);
        
        // TODO: better depth system
        if (depth >= 9999.f) { // Skybox
            energy *= vec3(0.9f,0.98,0.999f); emission = true;
            //energy *= vec3(0.f); emission = true;
        } else 
        if (depth == PrimaryRay.fdata.z) { // Primitive
            energy *= PrimaryRay.normals.xyz * 0.5f + 0.5f;
        } else 
        if (depth == sdepth) { // Light Sphere 
            //energy *= 10.f.xxx; emission = true; // TODO: USE only for reflections, transmissions, speculars, glossy
            PrimaryRay.normals.xyz = normalize((origin.xyz + raydir.xyz * sdepth) - sphere.xyz);
        } else 
        if (depth == pdepth) { // Plane
            energy *= vec3(0.8f);
            PrimaryRay.normals.xyz = vec3(0.f,1.f,0.f);
        } else { // Error as Skybox
            energy *= vec3(0.9f,0.98,0.999f); emission = true;
            //energy *= vec3(0.f); emission = true;
        };
        origin.xyz += raydir.xyz * depth;
        if (i == 0u) { smorig.xyz = origin.xyz; };

        // 
        raydir.xyz = randomHemisphereCosine(PrimaryRay.normals.xyz,uvec2(gl_LaunchIDNV.xy));
        origin.xyz += faceforward(PrimaryRay.normals.xyz,raydir.xyz,-PrimaryRay.normals.xyz) * 0.0001f;
        lnormal.xyz = PrimaryRay.normals.xyz;

        // 
        if (emission) break; // if found emission, break
    };

    if (emission) { signal.xyz += energy; } else {};

    // 
    const vec4 directSample = imageLoad(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy));
    const vec4 locateSample = imageLoad(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy));
    imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), signal + directSample);
    //imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), signal);
    imageStore(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy), vec4(smorig.xyz, 1.f));
};
