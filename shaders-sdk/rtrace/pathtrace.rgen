#version 460 core // #
#extension GL_GOOGLE_include_directive : require
#extension GL_NV_ray_tracing           : require
#include "./driver.glsl"


#define ENABLE_RASTERIZE_STAGE
layout ( binding = 2, set = 1 ) uniform accelerationStructureNV Scene;
layout ( location = 0 ) rayPayloadNV RayPayloadData PrimaryRay;
layout ( location = 1 ) rayPayloadNV RayPayloadData ShadowsRay;


vec4 shiftByPixel(in vec4 wpos, inout uvec2 seed){
    vec2 sizpx = vec2(gl_LaunchSizeNV.xy);
    vec2 shift = random2(seed);
    vec4 sspos = vec4(vec4(divW(wpos * projectionInv),1.f) * modelviewInv, 1.f);
    sspos.xy += shift/sizpx;
    return vec4(divW(vec4(sspos * modelview, 1.f) * projection), 1.f);
};


// TODO: Hybrid Path Tracing
void main() { // Hi-DPI adaptation
    ShadowsRay.position  = PrimaryRay.position  = vec4(0.f);
    ShadowsRay.texcoords = PrimaryRay.texcoords = vec4(0.f);
    ShadowsRay.normals   = PrimaryRay.normals   = vec4(0.f);
    ShadowsRay.fdata.xyz = PrimaryRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
    ShadowsRay.udata.xyz = PrimaryRay.udata.xyz = uvec3(0u);

    // 
    const ivec2 curPixel = ivec2(gl_LaunchIDNV.xy), invPixel = ivec2(curPixel.x,gl_LaunchSizeNV.y-curPixel.y-1u);
    const ivec2 sizPixel = ivec2(gl_LaunchSizeNV.xy);
    const uint packed = pack32(u16vec2(curPixel));

    // 
    const Box box = { -1.f.xxx, 1.f.xxx }; // TODO: Change Coordinate
    const vec4 sphere = vec4(vec3(8.f,8.f,4.f), 4.f); 
    const vec3 lightc = 10.f.xxx;

    //const vec2 shift = random2(uvec2(rdata[0],packed)), pixel = (vec2(invPixel)+0.5f)+(shift*2.f-1.f)*0.5f;
    const vec2 shift = 0.5f.xx, pixel = (vec2(invPixel)+0.5f)+(shift*2.f-1.f)*0.5f;
    const vec4 colourSample = texture(frameBuffers[COLORING], pixel);
    const vec4 normalSample = texture(frameBuffers[NORMALED], pixel);
    const vec4 worldsSample = texture(frameBuffers[POSITION], pixel);
    const vec4 emitedSample = texture(frameBuffers[EMISSION], pixel);
    const vec3 cameraSample = vec4(worldsSample.xyz,1.f)*modelview;
    uvec2 seed = uvec2(packed,rdata.x);

    [[unroll]] for (uint32_t I=0;I<2;I++) { // Path Traced Diffuse Global Illumination
        int ITERATION_COUNT = 2;
        int TRANSPARENT_COUNT = 2;

#ifdef ENABLE_RASTERIZE_STAGE
        vec3 raydir  = (modelview * normalize(cameraSample.xyz)).xyz;
        vec3 origin  = worldsSample.xyz;
        vec3 normal = normalSample.xyz;
#else
        vec3 origin = screen2world(vec3((vec2(pixel)/vec2(sizPixel))*2.f-1.f,0.001f));
        vec3 target = screen2world(vec3((vec2(pixel)/vec2(sizPixel))*2.f-1.f,0.999f));
        vec3 raydir = normalize(target - origin);
        vec3 normal = vec3(0.f);
#endif

        vec3 forign = origin.xyz;
        vec3 fnorml = normal.xyz;

        //
        vec4 gNormal = vec4(normal,0.f);
        vec4 gSignal = vec4(0.f.xxx,1.f);
        vec3 gEnergy = 1.f.xxx;
        vec2 gTexcoord = 0.f.xx;

        int i = 0; 
#ifdef ENABLE_RASTERIZE_STAGE // complete first stage
        gNormal.xyz = faceforward(gNormal.xyz, raydir.xyz,gNormal.xyz); 
        raydir.xyz = I == 0 ? randomHemisphereCosine(gNormal.xyz,seed) : reflectGlossy(raydir.xyz, gNormal.xyz, seed, 0.1f);
        origin.xyz += faceforward(gNormal.xyz,-raydir.xyz,gNormal.xyz) * 0.0001f, i++; // pre-correction
#endif

        if (!all(fequal(worldsSample.xyz,0.f.xxx))) 
        for (;i < ITERATION_COUNT; i++) { //

            // Shadows Rays
            if (i >= (I == 0 ? 1u : 2u)) {
                vec3 lorign = origin;
                const vec3 lightp = sphere.xyz + randomSphere(seed) * sphere.w; float shdist = distance(lightp.xyz,lorign.xyz);
                const vec3 lightd = normalize(lightp.xyz - lorign.xyz);
                
                float sdepth = raySphereIntersect(origin.xyz,lightd,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
                float depth = 0.f;
                for (uint j=0;j<2u;j++) {
                    traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                        0, 1, 0,
                        lorign.xyz, 0.0001f,
                        lightd.xyz, 10000.f,
                        1);
                    
                    depth = min(sdepth,depth+ShadowsRay.fdata.z); // Generalize Shadow Depth

                    const MaterialUnit unit = materials[0u].data[meshInfo[ShadowsRay.udata.w].materialID];
                      vec4  diffuseColor = unit. diffuseTexture >= 0 ? texture(textures[nonuniformEXT(unit. diffuseTexture)],ShadowsRay.texcoords.xy) : unit.diffuse;
                    //vec4  normalsColor = unit. normalsTexture >= 0 ? texture(textures[nonuniformEXT(unit. normalsTexture)],ShadowsRay.texcoords.xy) : unit.normals;
                    //vec4 specularColor = unit.specularTexture >= 0 ? texture(textures[nonuniformEXT(unit.specularTexture)],ShadowsRay.texcoords.xy) : unit.specular;
                    //vec4 emissionColor = unit.emissionTexture >= 0 ? texture(textures[nonuniformEXT(unit.emissionTexture)],ShadowsRay.texcoords.xy) : unit.emission;

                    lorign.xyz += lightd.xyz * ShadowsRay.fdata.z;
                    if (diffuseColor.w > 0.001f || depth >= (shdist-0.0001f)) { break; };
                    lorign.xyz += faceforward(ShadowsRay.normals.xyz,-lightd.xyz,ShadowsRay.normals.xyz) * 0.0001f;
                };

                const float cos_a_max = sqrt(1.f - clamp(sphere.w * sphere.w / dot(sphere.xyz-origin.xyz, sphere.xyz-origin.xyz), 0.f, 1.f));
                if (depth >= (shdist-0.0001f)) { gSignal += vec4(gEnergy * 2.f * (1.f - cos_a_max) * clamp(dot( lightd, gNormal.xyz ), 0.f, 1.f) * lightc, 0.f); };
            };

            // Primary Rays
            traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                0, 1, 0,
                origin.xyz, 0.0001f,
                raydir.xyz, 10000.f,
                0);

            // 
            gNormal = PrimaryRay.normals;
            gTexcoord = PrimaryRay.texcoords.xy;

            // 
            const MaterialUnit unit = materials[0u].data[meshInfo[PrimaryRay.udata.w].materialID];
            vec4  diffuseColor = unit. diffuseTexture >= 0 ? texture(textures[nonuniformEXT(unit. diffuseTexture)],gTexcoord.xy) : unit.diffuse;
            vec4  normalsColor = unit. normalsTexture >= 0 ? texture(textures[nonuniformEXT(unit. normalsTexture)],gTexcoord.xy) : unit.normals;
            vec4 specularColor = unit.specularTexture >= 0 ? texture(textures[nonuniformEXT(unit.specularTexture)],gTexcoord.xy) : unit.specular;
            vec4 emissionColor = unit.emissionTexture >= 0 ? texture(textures[nonuniformEXT(unit.emissionTexture)],gTexcoord.xy) : unit.emission;

            // 
            float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
            float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
            float  depth = PrimaryRay.fdata.z;
            //float  depth = min(PrimaryRay.fdata.z,sdepth);


            // TODO: better depth system
            bool couldReflection = false;

            [[flatten]] if (depth >= 9999.f) { BACKSKY_COLOR; };
            [[flatten]] if (depth == PrimaryRay.fdata.z) { if (diffuseColor.w > 0.001f) {
                gSignal.xyz += i > 0 ? gEnergy.xyz * emissionColor.xyz * emissionColor.w : 0.f.xxx;
                gEnergy *= max(i > 0 ? max(DIFFUSE_COLOR - emissionColor.xyz*emissionColor.w, 0.f.xxx) : 1.f.xxx, 0.f.xxx);
            }};
            [[flatten]] if (depth == sdepth) { // Light Sphere
                BACKSKY_COLOR;
                gNormal.xyz = normalize((origin.xyz + raydir.xyz * sdepth) - sphere.xyz);
            };

            origin.xyz += raydir.xyz * depth;
            if (i == 0u) { 
                forign =  origin.xyz, 
                fnorml = gNormal.xyz; 
            };

            // 
            gNormal.xyz = faceforward(gNormal.xyz,raydir.xyz,gNormal.xyz); // interverse into incoming ray
            if (diffuseColor.w > 0.001f) { // Reflection
                raydir.xyz = i == 0 ? reflectGlossy(raydir.xyz, gNormal.xyz, seed, 0.1f) : randomHemisphereCosine(gNormal.xyz,seed);
            } else { // Fully Transparent, Continue...
                raydir.xyz = normalize(raydir.xyz); 
                if (TRANSPARENT_COUNT > 0) { TRANSPARENT_COUNT--; i--; };
            };
            origin.xyz += faceforward(gNormal.xyz,-raydir.xyz,gNormal.xyz) * 0.0001f;
            if (dot(gEnergy.xyz,1.f.xxx) <= 0.0001f || depth >= 9999.f) { break; }; // 

        } else {
            gSignal.xyz += fma(gEnergy.xyz, 1.f.xxx,gSignal.xyz), gEnergy *= 0.f;
            forign.xyz = 0.f.xxx;
        };

        // 
        if (I == 0) { // Store for Diffuse
            const vec4 directSample = imageLoad(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy));
            const vec4 locateSample = imageLoad(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy));
            imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), gSignal + directSample);
            imageStore(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy), vec4(forign,1.f));
            imageStore(writeImages[NORMALED], ivec2(gl_LaunchIDNV.xy), vec4(fnorml,1.f));
        };

        if (I == 1) { // Titanic OS
            imageStore(writeImages[REFLECTS], ivec2(gl_LaunchIDNV.xy), vec4(gSignal.xyz,0.1f));
        };

        memoryBarrier();
    };
};
