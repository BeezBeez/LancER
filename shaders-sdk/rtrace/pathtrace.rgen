#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive          : require
#include "./driver.glsl"

#define ENABLE_RASTERIZE_STAGE

layout ( binding = 2, set = 1 ) uniform accelerationStructureNV Scene;
layout ( location = 0 ) rayPayloadNV RayPayloadData PrimaryRay;
layout ( location = 1 ) rayPayloadNV RayPayloadData ShadowsRay;


vec4 shiftByPixel(in vec4 wpos, in uint packed){
    vec2 sizpx = vec2(gl_LaunchSizeNV.xy);
    vec2 shift = random2(uvec2(rdata[0],packed));
    vec4 sspos = vec4(vec4(divW(wpos * projectionInv),1.f) * modelviewInv, 1.f);
    sspos.xy += shift/sizpx;
    return vec4(divW(vec4(sspos * modelview, 1.f) * projection), 1.f);
};


// TODO: Hybrid Path Tracing
void main() { // Hi-DPI adaptation
    PrimaryRay.position  = vec4(0.f);
    PrimaryRay.texcoords = vec4(0.f);
    PrimaryRay.normals   = vec4(0.f);
    PrimaryRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
    PrimaryRay.udata.xyz = uvec3(0u);

    // 
    ivec2 curPixel = ivec2(gl_LaunchIDNV.xy), invPixel = ivec2(curPixel.x,gl_LaunchSizeNV.y-curPixel.y-1u);
    ivec2 sizPixel = ivec2(gl_LaunchSizeNV.xy);
    const uint packed = pack32(u16vec2(curPixel));

    // TODO: transform normals (include in ray tracers)
    //const vec2 shift = random2(uvec2(rdata[0],packed)), pixel = (vec2(invPixel)+0.5f)+(shift*2.f-1.f)*0.5f;
    const vec2 shift = 0.5f.xx, pixel = (vec2(invPixel)+0.5f)+(shift*2.f-1.f)*0.5f;
    const vec4 colourSample = texture(frameBuffers[COLORING], pixel);
    const vec4 normalSample = texture(frameBuffers[NORMALED], pixel);
    const vec4 worldsSample = texture(frameBuffers[POSITION], pixel);
    const vec3 cameraSample = vec4(worldsSample.xyz,1.f)*modelview;
    const bool isBackground = all(fequal(worldsSample.xyz,0.f.xxx));

    // 
#ifdef ENABLE_RASTERIZE_STAGE
    vec3 raydir  = (modelview * normalize(cameraSample.xyz)).xyz;
    vec3 origin  = worldsSample.xyz;
    vec3 lnormal = normalSample.xyz;
#else
    vec3 origin = screen2world(vec3((pixel/sizPixel)*2.f-1.f,0.001f));
    vec3 target = screen2world(vec3((pixel/sizPixel)*2.f-1.f,0.999f));
    vec3 raydir = normalize(target - origin);
    vec3 lnormal = vec3(0.f);
#endif

    vec3 forign = origin.xyz;
    vec3 fnorml = lnormal.xyz;

    //
    vec4 gNormals = normalSample;
    vec4 gSignal = vec4(0.f,0.f,0.f,1.f);
    vec3 gEnergy = 1.f.xxx;

    // 
    bool emission = false;

    // 
    Box box = { -1.f.xxx, 1.f.xxx }; // TODO: Change Coordinate
    vec4 sphere = vec4(vec3(8.f,8.f,4.f), 4.f); vec3 lightc = 10.f.xxx;

    // 
    const uint ITERATION_COUNT = 4u;

#ifdef ENABLE_RASTERIZE_STAGE // complete first stage
    bool couldReflection = false; // TODO: Dynamic That Value
    if (couldReflection) {
        raydir.xyz = reflect(raydir.xyz, lnormal);
    } else {
        raydir.xyz = randomHemisphereCosine(lnormal,uvec2(gl_LaunchIDNV.xy));
    };
    origin.xyz += faceforward(lnormal,-raydir.xyz,lnormal) * 0.0001f; // pre-correction

    uint i = 1u; if (!isBackground) 
    for (i = 1u; i < ITERATION_COUNT; i++) { //
#else
    uint i = 0u; if (true) //if (!isBackground) 
    for (i = 0u; i < ITERATION_COUNT; i++) { //
#endif

        ShadowsRay.position  = vec4(0.f);
        ShadowsRay.texcoords = vec4(0.f);
        ShadowsRay.normals   = vec4(0.f);
        ShadowsRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
        ShadowsRay.udata.xyz = uvec3(0u);

        // Shadows Rays
        if (i >= 1u) {
            vec3 lightp = sphere.xyz + randomSphere(uvec2(gl_LaunchIDNV.xy)) * sphere.w; float shdist = distance(lightp.xyz,origin.xyz);
            vec3 lightd = normalize(lightp.xyz - origin.xyz);

            traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                1, 1, 1,
                origin.xyz, 0.0001f,
                lightd.xyz, 10000.f,
                1);

            float sdepth = raySphereIntersect(origin.xyz,lightd,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
            float depth = min(sdepth,ShadowsRay.fdata.z)+sphere.w;
            //float depth = ShadowsRay.fdata.z;

            float cos_a_max = sqrt(1.f - clamp(sphere.w * sphere.w / dot(sphere.xyz-origin.xyz, sphere.xyz-origin.xyz), 0.f, 1.f));
            if (depth >= (shdist-0.001f)) { gSignal += vec4(gEnergy * 2.f * (1.f - cos_a_max) * clamp(dot( lightd, lnormal ), 0.f, 1.f) * lightc, 0.f); };
        };

        // Primary Rays
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
            0, 1, 0,
            origin.xyz, 0.0001f,
            raydir.xyz, 10000.f,
            0);

        // 
        gNormals = PrimaryRay.normals;

        // 
        float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
        float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
        float depth = min(PrimaryRay.fdata.z,sdepth);

        // TODO: better depth system
        bool couldReflection = false;
        if (depth >= 9999.f) { // Skybox
            gSignal.xyz = fma(gEnergy.xyz, (i > 0u ? gSkyColor : 1.f.xxx), gSignal.xyz), gEnergy *= 0.f;
        } else 
        if (depth == PrimaryRay.fdata.z) { // Primitive
            gEnergy *= i > 0u ? DIFFUSE_COLOR : 1.f.xxx;
        } else 
        if (depth == sdepth) { // Light Sphere
            gEnergy *= 0.f;
            //gSignal.xyz = fma(gEnergy.xyz, lightc.xyz, gSignal.xyz), gEnergy *= 0.f;
            gNormals.xyz = normalize((origin.xyz + raydir.xyz * sdepth) - sphere.xyz);
        } else 
        if (depth == pdepth) { // Plane
            gEnergy *= vec3(0.8f);
            gNormals.xyz = vec3(0.f,1.f,0.f);
        } else { // Error as Skybox
            gSignal.xyz = fma(gEnergy.xyz, (i > 0u ? gSkyColor : 1.f.xxx), gSignal.xyz), gEnergy *= 0.f;
        };
        origin.xyz += raydir.xyz * depth;

        // 
        gNormals.xyz = faceforward(gNormals.xyz,raydir.xyz,gNormals.xyz); // interverse into incoming ray
        if (couldReflection) {
            raydir.xyz = reflect(raydir.xyz, gNormals.xyz);
        } else {
            raydir.xyz = randomHemisphereCosine(gNormals.xyz,uvec2(gl_LaunchIDNV.xy));
        };
        origin.xyz += faceforward(gNormals.xyz,-raydir.xyz,gNormals.xyz) * 0.0001f;
        lnormal.xyz = gNormals.xyz;

        // 
        if (i == 0u) { // 
            forign =  origin.xyz;
            fnorml = lnormal.xyz;
        };

        // 
        if (dot(gEnergy.xyz,1.f.xxx) <= 0.0001f) { break; }; // if found emission, break
    } else {
        gSignal.xyz = fma(gEnergy.xyz, 1.f.xxx,gSignal.xyz); emission = true;
        forign.xyz = 0.f.xxx;
    };

    // 
    const vec4 directSample = imageLoad(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy));
    const vec4 locateSample = imageLoad(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy));
    imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), gSignal + directSample);
    //imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), gSignal);
    imageStore(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy), vec4(forign,1.f));
    imageStore(writeImages[NORMALED], ivec2(gl_LaunchIDNV.xy), vec4(fnorml,1.f));
};
