#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_realtime_clock : require
precision highp float;
precision highp int;
#include "./index.glsl"


layout (binding = 1, set = 0) uniform accelerationStructureNV Scene;

//layout ( location = 0 ) rayPayloadNV RayPayload PrimaryRay;

RayPayloadData PrimaryRay;

//const float PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   
//const float PI  = 3.14159265358979323846264 * 00000.1; // PI
//const float SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two

//float gold_noise(in vec2 coordinate, in float seed){
//    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);
//}

//const float PIh = 3.14159265358979323846264*2.0;
//const float BLUR_RADIUS = 20.f;

//const vec4 shapeColors[2] = {vec4(0.1f,0.6f,0.1f,0.6f), vec4(0.6f,0.1f,0.1f,0.6f)};





void main() {
    // Hi-DPI adaptation
    const vec2 curPixel = vec2(gl_LaunchIDNV.xy) + 0.5f;
    const vec2 sizPixel = vec2(gl_LaunchSizeNV.xy);

    vec4 origss = vec4(divW(vec4((curPixel/sizPixel)*2.f-1.f,0.001f,1.f)*projectionInv),1.f);
    vec4 targss = vec4(divW(vec4((curPixel/sizPixel)*2.f-1.f,0.999f,1.f)*projectionInv),1.f);

    vec3 origin = origss*modelviewInv;
    vec3 target = targss*modelviewInv;
    vec3 raydir = normalize(target - origin);

    vec3 signal = vec3(0.f,0.f,0.f);
    vec3 energy = vec3(1.f,1.f,1.f);
    bool emission = false;

    vec3 lastps = origin.xyz;

    signal = raydir.xyz*0.5f+0.5f;//normal;

    uint i = 0u;
    for (i = 0u;i<4u;i++) {
        /*// TODO: Add Triangle Tracing
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                 0,
                 1,
                 0,
                 origin.xyz,
                 0.001f,
                 raydir.xyz,
                 100.f,
                 0);*/


        Box box = { -1.f.xxx, 1.f.xxx };
        vec4 sphere = vec4(vec3(0.f,12.f,12.f), 1.f);
        vec2 boxdepth = boxIntersect(origin.xyz, raydir.xyz, box.min, box.max); 
        float bdepth = (boxdepth.x <= boxdepth.y && boxdepth.y >= 0.f) ? (boxdepth.x >= 0.f ? min(boxdepth.x, boxdepth.y) : max(boxdepth.x, boxdepth.y)) : 10000.f;
        float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : 0.f;
        float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
        float depth = min(min(sdepth, bdepth), pdepth);
        vec3 lastps = origin.xyz + raydir.xyz*depth;



        if (depth >= 10000.f) { // Midnight Skylight Depth
            PrimaryRay.udata.x = 1u;
            PrimaryRay.fdata.xyz = 0.f.xxx;//vec3(0.9f, 0.96f, 0.99f) * 0.5f;
            PrimaryRay.normal.xyz = raydir.xyz;
        } else 

        if (fequal(depth, sdepth)) { // Sphere Light Depth
            PrimaryRay.udata.x = 1u;
            PrimaryRay.fdata.xyz = vec3(2.f, 2.f, 2.f);
            PrimaryRay.normal.xyz = normalize(lastps.xyz - sphere.xyz);
        } else 

        if (fequal(depth, bdepth)) { // Box Depth
            PrimaryRay.udata.x = 0u;
            PrimaryRay.fdata.xyz = vec3(0.9f, 0.6f, 0.6f);
            PrimaryRay.normal.xyz = normalize(boxNormal(lastps.xyz,box.min,box.max));
        } else 

        if (fequal(depth, pdepth)) { // Plane Depth
            PrimaryRay.udata.x = 0u;
            PrimaryRay.fdata.xyz = vec3(0.9f, 0.9f, 0.9f);
            PrimaryRay.normal.xyz = vec3(0.f,1.f,0.f);
        } else 
        
        {
            PrimaryRay.udata.x = 0u;
            PrimaryRay.fdata.xyz = vec3(0.f);
            PrimaryRay.normal.xyz = vec3(0.f,0.f,0.f);
        }

        // 
        origin.xyz = lastps.xyz + faceforward(PrimaryRay.normal.xyz,raydir.xyz,PrimaryRay.normal.xyz) * 0.0001f;
        raydir.xyz = randomHemisphereCosine(PrimaryRay.normal.xyz,uvec2(gl_LaunchIDNV.xy));
        energy.xyz *= PrimaryRay.fdata.xyz;

        // 
        if ( i == 0 ) { // Like In Rasterization
            //signal = PrimaryRay.normal.xyz*0.5f+0.5f;
            imageStore(writeImages[SAMPLES], ivec2(gl_LaunchIDNV.xy), vec4(lastps,1.f));
            imageStore(writeImages[COLORED], ivec2(gl_LaunchIDNV.xy), vec4(exchange(energy.xyz,1.f.xxx),1.f));
        };

        // Finalize 
        if (dot(energy.xyz,1.f.xxx) < 0.001f) { emission = false; break; };
        if (PrimaryRay.udata.x == 1u) { emission = true; break; };
    };

    // 
    if (!emission) { energy *= 0.f; };

    // Diffuse Samples Overall
    if ( i > 0 ) {
        const vec4 originSample = texelFetch(frameBuffers[DIFFUSE],ivec2(gl_LaunchIDNV.xy),0);
        imageStore(writeImages[DIFFUSE], ivec2(gl_LaunchIDNV.xy), vec4(originSample.xyz + energy, originSample.w + (emission?1.f:0.f)));
    };

    
};
