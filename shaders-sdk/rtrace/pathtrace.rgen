#version 460 core
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive          : require
#include "./driver.glsl"

#define ENABLE_RASTERIZE_STAGE

layout ( binding = 2, set = 1 ) uniform accelerationStructureNV Scene;
layout ( location = 0 ) rayPayloadNV RayPayloadData PrimaryRay;
layout ( location = 1 ) rayPayloadNV RayPayloadData ShadowsRay;


vec4 shiftByPixel(in vec4 wpos, in uint packed){
    vec2 sizpx = vec2(gl_LaunchSizeNV.xy);
    vec2 shift = random2(uvec2(rdata[0],packed));
    vec4 sspos = vec4(vec4(divW(wpos * projectionInv),1.f) * modelviewInv, 1.f);
    sspos.xy += shift/sizpx;
    return vec4(divW(vec4(sspos * modelview, 1.f) * projection), 1.f);
};


// TODO: Hybrid Path Tracing
void main() { // Hi-DPI adaptation
    PrimaryRay.position  = vec4(0.f);
    PrimaryRay.texcoords = vec4(0.f);
    PrimaryRay.normals   = vec4(0.f);
    PrimaryRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
    PrimaryRay.udata.xyz = uvec3(0u);

    // 
    ivec2 curPixel = ivec2(gl_LaunchIDNV.xy), invPixel = ivec2(gl_LaunchIDNV.x,gl_LaunchSizeNV.y-gl_LaunchIDNV.y-1u);
    ivec2 sizPixel = ivec2(gl_LaunchSizeNV.xy);
    uint packed = pack32(u16vec2(curPixel));

    // TODO: transform normals (include in ray tracers)
    //const vec2 shift = random2(uvec2(rdata[0],packed)), pixel = (vec2(invPixel)+0.5f)+(shift*2.f-1.f)*0.5f;
    const vec2 shift = 0.5f.xx, pixel = (vec2(invPixel)+0.5f)+(shift*2.f-1.f)*0.5f;
    const vec4 colourSample = texture(frameBuffers[COLORING], pixel);
    const vec4 normalSample = texture(frameBuffers[NORMALED], pixel);
    const vec4 worldsSample = texture(frameBuffers[POSITION], pixel);
    //const vec4 colourSample = texelFetch(frameBuffers[COLORING], invPixel, 0);
    //const vec4 normalSample = texelFetch(frameBuffers[NORMALED], invPixel, 0);
    //const vec4 worldsSample = texelFetch(frameBuffers[POSITION], invPixel, 0);
    const vec3 cameraSample = vec4(worldsSample.xyz,1.f)*modelview;
    const bool isBackground = all(fequal(worldsSample.xyz,0.f.xxx));

    // 
#ifdef ENABLE_RASTERIZE_STAGE
    vec3 raydir = (modelview * normalize(cameraSample.xyz)).xyz;
    vec3 origin = worldsSample.xyz;
    vec3 lnormal = normalSample.xyz;
    vec3 forign = origin.xyz;
#else
    vec3 origin = screen2world(vec3((pixel/sizPixel)*2.f-1.f,0.001f));
    vec3 target = screen2world(vec3((pixel/sizPixel)*2.f-1.f,0.999f));
    vec3 raydir = normalize(target - origin);
    vec3 lnormal = vec3(0.f);
    vec3 forign = origin.xyz;
#endif



    // DEBUG
    //origin.xyz -= raydir.xyz * 0.1f;

    // 
    //vec4 signal = vec4(0.f,0.f,0.f,1.f);
    vec4 signal = vec4(0.f,0.f,0.f,1.f);
    //vec3 energy = 1.f.xxx;

    bool emission = false;

//random2(uvec2(rdata[0],packed))

    // 
    Box box = { -1.f.xxx, 1.f.xxx }; // TODO: Change Coordinate
    vec4 sphere = vec4(vec3(8.f,8.f,4.f), 4.f); vec3 lightc = 10.f.xxx;
    const vec3 skyColor = vec3(0.9f,0.98,0.999f); // TODO: Use 1.f and texture shading (include from rasterization)
    //const vec3 skyColor = 0.f.xxx;

    // 
    const uint ITERATION_COUNT = 4u;

#ifdef ENABLE_RASTERIZE_STAGE // complete first stage
    bool couldReflection = false; // TODO: Dynamic That Value
    vec3 energy = 1.f.xxx;
    if (couldReflection) {
        raydir.xyz = reflect(raydir.xyz, lnormal);
    } else {
        raydir.xyz = randomHemisphereCosine(lnormal,uvec2(gl_LaunchIDNV.xy));
    };
    origin.xyz += faceforward(lnormal,-raydir.xyz,lnormal) * 0.0001f; // pre-correction
    
    uint i = 1u; if (!isBackground) 
    for (i = 1u; i < ITERATION_COUNT; i++) { //
#else
    vec3 energy = 1.f.xxx;//sqrt(colourSample.xyz);
    uint i = 0u; if (true) //if (!isBackground) 
    for (i = 0u; i < ITERATION_COUNT; i++) { //
#endif

        ShadowsRay.position  = vec4(0.f);
        ShadowsRay.texcoords = vec4(0.f);
        ShadowsRay.normals   = vec4(0.f);
        ShadowsRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
        ShadowsRay.udata.xyz = uvec3(0u);

        // Shadows Rays
        if (i >= 1u) {
            vec3 lightp = sphere.xyz + randomSphere(uvec2(gl_LaunchIDNV.xy)) * sphere.w; float shdist = distance(lightp.xyz,origin.xyz);
            vec3 lightd = normalize(lightp.xyz - origin.xyz);

            traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                1, 1, 1,
                origin.xyz, 0.0001f,
                lightd.xyz, 10000.f,
                1);

            float sdepth = raySphereIntersect(origin.xyz,lightd,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
            float depth = min(sdepth,ShadowsRay.fdata.z)+sphere.w;
            //float depth = ShadowsRay.fdata.z;

            float cos_a_max = sqrt(1.f - clamp(sphere.w * sphere.w / dot(sphere.xyz-origin.xyz, sphere.xyz-origin.xyz), 0.f, 1.f));
            if (depth >= (shdist-0.001f)) { signal += vec4(energy * (2.f * (1.f - cos_a_max)) * clamp(dot( lightd, lnormal ), 0.f, 1.f) * lightc * 2.f, 0.f); };
        };

        // Primary Rays
        traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
            0, 1, 0,
            origin.xyz, 0.0001f,
            raydir.xyz, 10000.f,
            0);

        // 
        float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
        float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
        //float depth = min(min(PrimaryRay.fdata.z,sdepth),pdepth);
        float depth = min(PrimaryRay.fdata.z,sdepth);

        // TODO: better depth system
        bool couldReflection = false;
        if (depth >= 9999.f) { // Skybox
            signal.xyz += energy * (i > 0u ? skyColor : 1.f.xxx); energy *= 0.f;
        } else 
        if (depth == PrimaryRay.fdata.z) { // Primitive
            vec3 diffuseColor = vec3(0.9f,0.8f,0.8f)*0.75f * (PrimaryRay.normals.xyz*0.5f+0.5f);
            energy *= i > 0u ? diffuseColor : 1.f.xxx;//sqrt(diffuseColor);
            //vec3 forig = raydir.xyz * depth + origin.xyz;
            //vec3 diffuseColor = vec3(0.5f,1.f,0.5f);
            //if (forig.x >= 0.f && forig.z >= 0.f) diffuseColor = vec3(1.f,1.f,0.5f);
            //if (forig.x >= 0.f && forig.z <= 0.f) diffuseColor = vec3(1.f,0.5f,0.5f);
            //if (forig.x <= 0.f && forig.z >= 0.f) diffuseColor = vec3(0.5f,0.5f,1.f);
            //energy *= diffuseColor*0.8f;
        } else 
        if (depth == sdepth) { // Light Sphere
            //signal.xyz += energy * lightc; emission = true;
            signal.xyz += energy * 0.f; energy *= 0.f; // confirm diffuse lightning
            PrimaryRay.normals.xyz = normalize((origin.xyz + raydir.xyz * sdepth) - sphere.xyz);
        } else 
        if (depth == pdepth) { // Plane
            energy *= vec3(0.8f);
            PrimaryRay.normals.xyz = vec3(0.f,1.f,0.f);
            //couldReflection = true;
        } else { // Error as Skybox
            signal.xyz += energy * (i > 0u ? skyColor : 1.f.xxx); energy *= 0.f;
        };
        origin.xyz += raydir.xyz * depth;

        // 
        PrimaryRay.normals.xyz = faceforward(PrimaryRay.normals.xyz,raydir.xyz,PrimaryRay.normals.xyz); // interverse into incoming ray
        if (couldReflection) {
            raydir.xyz = reflect(raydir.xyz, PrimaryRay.normals.xyz);
        } else {
            raydir.xyz = randomHemisphereCosine(PrimaryRay.normals.xyz,uvec2(gl_LaunchIDNV.xy));
        };
        origin.xyz += faceforward(PrimaryRay.normals.xyz,-raydir.xyz,PrimaryRay.normals.xyz) * 0.0001f;
        lnormal.xyz = PrimaryRay.normals.xyz;
        if (i == 0u) { forign = origin.xyz; };

        // 
        if (dot(energy.xyz,1.f.xxx) <= 0.0001f) { break; }; // if found emission, break
    } else {
        signal.xyz += energy * 1.f.xxx; emission = true;
        forign.xyz = 0.f.xxx;
    };

    //if (emission) { signal += vec4(energy, 1.f); } else { signal.w = 1.f; };

    // 
    const vec4 directSample = imageLoad(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy));
    const vec4 locateSample = imageLoad(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy));
    imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), signal + directSample);
    //imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), signal);
    imageStore(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy), vec4(forign,1.f));
};
